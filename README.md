| Problem / Technique | Time Complexity | Space Complexity | What it Does |
|--------------------|----------------|------------------|--------------|
| In-place sorting of linked list (using extra space) | O(N log N) | O(N) | Sorts a linked list using auxiliary storage like arrays |
| In-place sorting of linked list (without extra space) | O(N log N) | O(1) | Sorts a linked list by rearranging node links (merge sort) |
| Sorting by frequency | O(N log N) | O(N) | Sorts elements based on frequency of occurrence |
| Priority Queue using Linked List | O(N) (insert) | O(N) | Implements priority queue where elements are ordered by priority |
| Stock Span Problem (Brute Force) | O(N²) | O(1) | Calculates span by checking previous days one by one |
| Stock Span Problem (Using Stack) | O(N) | O(N) | Uses stack to efficiently compute stock spans |
| Modified Span Problem | O(N) | O(N) | Finds nearest greater element using stack |
| Bounded Stock Span | O(N) | O(N) | Computes stock span with a fixed upper limit |
| Tower of Hanoi | O(2ⁿ) | O(N) | Recursively moves disks between rods following rules |
| Celebrity Problem (Brute Force) | O(N²) | O(1) | Checks all pairs to find a celebrity |
| Celebrity Problem (Optimized) | O(N) | O(N) | Uses stack or two-pointer technique to find celebrity |
| Merge Sort on Doubly Linked List | O(N log N) | O(1) | Sorts a DLL by changing node links |
| Minimum Stack | O(1) per operation | O(N) | Supports push, pop, and getMin in constant time |
| Segregate Even and Odd Nodes in a List | O(N) | O(1) | Rearranges list so even nodes come before odd nodes |
| Sort Bitonic Doubly Linked List | O(N) | O(1) | Sorts a DLL that first increases then decreases |
| Maximum Sliding Window (Brute Force) | O(N × K) | O(N-K+1) | Finds max of each window by scanning all elements |
| Sort Bitonic Doubly Linked List | O(N log N) | O(N) (if iterative approach for reversing is used O(1)) | Sorts a DLL that first increases then decreases |
| Maximum Sliding Window (Brute Force) | O(N × K) | O(1) | Finds max of each window by scanning all elements |
| Maximum Sliding Window (Self-balancing Tree) | O(N log K) | O(K) | Maintains window elements in balanced BST |
| Maximum Sliding Window (Max Heap) | O(N log K) | O(K) | Uses heap to track maximum in each window |
| Maximum Sliding Window (Deque) | O(N) | O(K) | Uses deque to maintain decreasing order of elements |
